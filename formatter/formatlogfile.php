<?php
/**
 * Created by PhpStorm.
 * User: BrianHenryIE
 * Date: 9/11/18
 * Time: 4:26 PM
 */

// takes .xmpp.log file as input, outputs .xmpp.log.html

// deviceconsole time isn't as specific as Console

$filenames = scandir('.');

$logLineCaptureRegex = "/(?P<date>.*?\d\d:\d\d:\d\d) (?P<process>.*?)\(XMPPFrameworkLogger\.dylib\).*?: XMPPFramework (?P<action>\w.*?):(?P<data>.*)/"; //gm

foreach($filenames as $filename) {

	// TODO: don't overwrite (to make it easier to identify the html file that matches the recent log file)
	if(strpos($filename, '.xmpp.log') !== false
	   && strpos($filename, '.xmpp.log.html') === false
	   && strpos($filename, '.xmpp.log.json') === false) {

		$fileContents = file($filename);

		$dataArray = array();

		foreach($fileContents as $line) {

			$matches = null;

			$xmppLines = array();

			// Filter out log lines that don't reference the framework
			if ( strpos( $line, 'XMPPFramework' ) !== false ) {

				// NSLog can only log 1024 (?) characters (plus time, process?)
				// If a line is longer than this, it wasn't generated by this tweak
				// If it seems like it was, it's possible two lines are mistakenly concatenated

				// If the line is short enough, save it for later
				if ( strlen( $line ) < 1100 ) {

					$xmppLines[] = $line;

				} else {
					// If the line is too long, alert the user.

					// TODO. Address this automatically.
					print( "Line beginning:    " . substr( $line, 0, 200 ) . "    :is impossibly long. Edit the log file to fix.\n" );
				}
			}

			foreach ($xmppLines as $xmppLine) {

				if ( preg_match( $logLineCaptureRegex, $xmppLine, $matches ) ) {

					$parsedLine = array(
						'date'    => $matches['date'],
						'process' => $matches['process'],
						'action'  => $matches['action'],
						'data'    => trim( $matches['data'] )
					);

					// Merge split log lines
					if ( $matches['action'] === 'receive-partial-contd' || $matches['action'] === 'send-partial-contd' ) {
						$lastValue          = array_pop( $dataArray );
						$parsedLine['data'] = $lastValue['data'] . trim( $matches['data'] );
					}

					// Pare the partial line descriptions back to their generic description
					$parsedLine['action'] = strtr($matches['action'], array('partial'=>'','start'=>'','contd'=>'','-'=>''));

					$dataArray[] = $parsedLine;
				}
			}
		}

		// TODO: optional json output
		// $filename.'.json';
		// file_put_contents($filename.'.json', $json);
		// print( json_encode( $dataArray ) );

		$html  = '<!DOCTYPE html>';
		$html .= '<html lang="en">';
		$html .= '<head>';
		$html .= '<meta charset="utf-8"/>';

		// TODO: Inline this so files can be moved elsewhere?
		$html .= '<link rel="stylesheet" type="text/css" href="style.css">';

		$html .= '<div class="xmpp-stream">';

		foreach($dataArray as $message) {

			$action = $message['action'];
			$date = $message['date'];
			$data = $message['data'];

			// Split on \n
			$data = str_replace( '><', ">\n<", $data);

			$indentString = '   ';
			$indentCount = 0;

			$xmlLines = explode(PHP_EOL, $data);

			$indentedXmlLines = array();

			foreach($xmlLines as $xmlLine) {

				$xmlLine = trim($xmlLine);

				// Format JSON

				// <json>{"key":"value"}</json>

				if( substr( $xmlLine, 0, 6 ) === "<json>" && (substr( $xmlLine, -7 ) === "</json>") ){

					$indentedXmlLines[] = str_repeat($indentString, $indentCount) . '<json>';

					$jsonString = substr($xmlLine,6, strlen($xmlLine) - 6 - 7);

					$jsonString = json_encode(json_decode($jsonString), JSON_PRETTY_PRINT );

					$jsonLines = explode(PHP_EOL, $jsonString);

					foreach ($jsonLines as $jsonLine){
						$indentedXmlLines[] = str_repeat($indentString, $indentCount) . $jsonLine;
					}

					$indentedXmlLines[] = str_repeat($indentString, $indentCount) . '</json>';

					continue;
				}

				// Format XML

				// <?xml version='1.0' encoding='UTF-8'>
				if( substr( $xmlLine, 0, 2 ) === "<?") {
					$indentedXmlLines[] = $xmlLine;
					continue;
				}

				if( substr( $xmlLine, 0, 2 ) === "</"){

					$indentCount--;
					$indentCount = max($indentCount,0);

					$indentedXmlLines[] = str_repeat($indentString, $indentCount) . $xmlLine;

					continue;
				}

				// Looks like  <stream:features>
				if(substr_count($xmlLine, '<') == 1 && substr_count($xmlLine, '>') == 1 && substr_count($xmlLine, '/>') == 0) {
					// post increment indentation by 1
					// but indent as usual
					$indentedXmlLines[] = str_repeat($indentString, $indentCount) . $xmlLine;
					$indentCount++;
					continue;

				}

				// Looks like <mechanism>DIGEST-MD5</mechanism>
				if(substr_count($xmlLine, '</') == 1 && substr_count($xmlLine, '<') == 2 && substr_count($xmlLine, '>') == 2) {
					// don't change the indentation

					// but indent as usual

					$indentedXmlLines[] = str_repeat($indentString, $indentCount) . $xmlLine;

					continue;

				}

				$indentedXmlLines[] = str_repeat($indentString, $indentCount) . $xmlLine;

			}

			$data = implode( "\n", $indentedXmlLines);

			$data = "<xmp>$data</xmp>";

			$html .= "<div class=\"message\">";
			$html .= "<div class=\"$action\">";
			$html .= "<div class=\"chat-border\">";
			$html .= "<div class=\"chat\">";
			$html .= "<div class=\"date\">$date</div>";
			$html .= "<div class=\"xmpp-data\">";
			$html .= "<code class=\"prettyprint lang-xml\">".$data."</code>";
			$html .= "</div></div></div></div></div>\n";
		}

		$html .= '</div>';

		$html .= '<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?autorun=true"></script>';

		file_put_contents($filename.'.html', $html);

	}
}
